<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RatingController.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spring-boot-skeleton</a> &gt; <a href="index.source.html" class="el_package">com.nnk.springboot.controllers</a> &gt; <span class="el_source">RatingController.java</span></div><h1>RatingController.java</h1><pre class="source lang-java linenums">package com.nnk.springboot.controllers;

import com.nnk.springboot.domain.Rating;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.validation.BindingResult;
import com.nnk.springboot.dto.RatingDTO;
import com.nnk.springboot.mapper.RatingMapper;
import com.nnk.springboot.services.IRatingService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


import jakarta.validation.Valid;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Contrôleur Spring MVC pour la gestion des notations de crédit (Rating).
 * 
 * &lt;p&gt;Ce contrôleur gère l'ensemble des opérations CRUD (Create, Read, Update, Delete)
 * pour les entités Rating via une interface web. Il utilise le pattern DTO pour
 * la conversion des données entre les couches de présentation et de service,
 * avec une validation complète des standards de notation financière.&lt;/p&gt;
 * 
 * &lt;p&gt;Spécificités métier des notations de crédit :&lt;/p&gt;
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;strong&gt;Standards internationaux&lt;/strong&gt; : Respect des échelles Moody's, S&amp;P, Fitch&lt;/li&gt;
 *   &lt;li&gt;&lt;strong&gt;Validation croisée&lt;/strong&gt; : Cohérence entre agences de notation&lt;/li&gt;
 *   &lt;li&gt;&lt;strong&gt;Classification ordonnée&lt;/strong&gt; : Gestion des hiérarchies de qualité&lt;/li&gt;
 *   &lt;li&gt;&lt;strong&gt;Audit trail&lt;/strong&gt; : Traçabilité des modifications pour conformité&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * &lt;p&gt;Architecture respectant les principes SOLID :&lt;/p&gt;
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;strong&gt;SRP&lt;/strong&gt; : Gestion uniquement de l'interface web pour Rating&lt;/li&gt;
 *   &lt;li&gt;&lt;strong&gt;OCP&lt;/strong&gt; : Extensible pour nouvelles fonctionnalités de notation&lt;/li&gt;
 *   &lt;li&gt;&lt;strong&gt;LSP&lt;/strong&gt; : Respect du contrat Controller Spring&lt;/li&gt;
 *   &lt;li&gt;&lt;strong&gt;ISP&lt;/strong&gt; : Interface spécialisée pour les opérations Rating&lt;/li&gt;
 *   &lt;li&gt;&lt;strong&gt;DIP&lt;/strong&gt; : Dépend d'abstractions (Service, Mapper)&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * &lt;p&gt;Gestion d'erreurs robuste :&lt;/p&gt;
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;strong&gt;Validation Bean Validation&lt;/strong&gt; : Contrôle format des notations&lt;/li&gt;
 *   &lt;li&gt;&lt;strong&gt;Validation métier&lt;/strong&gt; : Cohérence inter-agences&lt;/li&gt;
 *   &lt;li&gt;&lt;strong&gt;Logging détaillé&lt;/strong&gt; : Traçabilité pour audit et maintenance&lt;/li&gt;
 *   &lt;li&gt;&lt;strong&gt;Messages utilisateur&lt;/strong&gt; : Feedback clair et actionnable&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * @author Poseidon Trading App
 * @version 1.0
 * @since 1.0
 */
@Controller
@RequestMapping(&quot;/rating&quot;)
<span class="fc" id="L60">public class RatingController {</span>
    
    /** Logger pour tracer les opérations et erreurs du contrôleur */
<span class="fc" id="L63">    private static final Logger logger = LoggerFactory.getLogger(RatingController.class);</span>

    /** Service de gestion des Rating injecté par Spring */
    @Autowired
    private IRatingService ratingService;

    /** Mapper pour la conversion entre entités et DTOs injecté par Spring */
    @Autowired
    private RatingMapper ratingMapper;

    /**
     * Affiche la liste de toutes les notations de crédit.
     * 
     * &lt;p&gt;Cette méthode récupère toutes les entités Rating depuis le service,
     * les convertit en DTOs pour l'affichage et gère les messages de statut
     * (succès/erreur) transmis via les paramètres de requête lors des redirections.&lt;/p&gt;
     * 
     * &lt;p&gt;Les notations sont automatiquement triées par numéro d'ordre croissant
     * (meilleure notation en premier) pour faciliter l'analyse de risque.&lt;/p&gt;
     * 
     * @param model Le modèle Spring MVC pour passer les données à la vue
     * @param success Paramètre optionnel contenant le message de succès à afficher
     * @param error Paramètre optionnel contenant le message d'erreur à afficher
     * @return Le nom de la vue Thymeleaf &quot;rating/list&quot;
     */
    @GetMapping(&quot;/list&quot;)
    public String home(Model model, 
                      @RequestParam(required = false) String success,
                      @RequestParam(required = false) String error) {
        try {
<span class="fc" id="L93">            List&lt;Rating&gt; ratings = ratingService.findAll();</span>
<span class="fc" id="L94">            List&lt;RatingDTO&gt; ratingDTOs = ratings.stream()</span>
<span class="fc" id="L95">                    .map(ratingMapper::toDTO)</span>
<span class="fc" id="L96">                    .collect(Collectors.toList());</span>
            
<span class="fc" id="L98">            model.addAttribute(&quot;ratings&quot;, ratingDTOs);</span>
<span class="fc" id="L99">            addStatusMessages(model, success, error);</span>
            
<span class="fc" id="L101">            logger.info(&quot;Successfully loaded {} credit ratings&quot;, ratings.size());</span>
<span class="fc" id="L102">            return &quot;rating/list&quot;;</span>
            
<span class="fc" id="L104">        } catch (Exception e) {</span>
<span class="fc" id="L105">            logger.error(&quot;Error loading ratings list&quot;, e);</span>
<span class="fc" id="L106">            model.addAttribute(&quot;errorMessage&quot;, &quot;Error loading credit ratings: &quot; + e.getMessage());</span>
<span class="fc" id="L107">            model.addAttribute(&quot;ratings&quot;, List.of()); // Liste vide en cas d'erreur</span>
<span class="fc" id="L108">            return &quot;rating/list&quot;;</span>
        }
    }

    /**
     * Affiche le formulaire de création d'une nouvelle notation de crédit.
     * 
     * &lt;p&gt;Cette méthode prépare un DTO vide qui sera utilisé pour lier
     * les données du formulaire de création d'un nouveau Rating.
     * Le formulaire permet la saisie des notations selon les trois
     * principales agences internationales.&lt;/p&gt;
     * 
     * @param model Le modèle Spring MVC pour passer les données à la vue
     * @return Le nom de la vue Thymeleaf &quot;rating/add&quot;
     */
    @GetMapping(&quot;/add&quot;)
    public String addRatingForm(Model model) {
<span class="fc" id="L125">        model.addAttribute(&quot;ratingDTO&quot;, new RatingDTO());</span>
<span class="fc" id="L126">        return &quot;rating/add&quot;;</span>
    }

    /**
     * Traite la soumission du formulaire de création d'une notation de crédit.
     * 
     * &lt;p&gt;Cette méthode valide les données soumises via Bean Validation (formats
     * des notations), les convertit de DTO vers entité via le mapper, applique
     * les validations métier via le service et sauvegarde. En cas de succès,
     * elle redirige vers la liste avec un message de confirmation.&lt;/p&gt;
     * 
     * &lt;p&gt;Validations appliquées :&lt;/p&gt;
     * &lt;ul&gt;
     *   &lt;li&gt;&lt;strong&gt;Format des notations&lt;/strong&gt; : Regex pour chaque agence&lt;/li&gt;
     *   &lt;li&gt;&lt;strong&gt;Cohérence inter-agences&lt;/strong&gt; : Équivalence des évaluations&lt;/li&gt;
     *   &lt;li&gt;&lt;strong&gt;Unicité numéro d'ordre&lt;/strong&gt; : Pas de doublons&lt;/li&gt;
     *   &lt;li&gt;&lt;strong&gt;Complétude minimale&lt;/strong&gt; : Au moins une notation requise&lt;/li&gt;
     * &lt;/ul&gt;
     * 
     * @param ratingDTO Les données du Rating à créer, validées avec Bean Validation
     * @param result Le résultat de la validation Bean Validation
     * @param model Le modèle Spring MVC pour passer les données à la vue
     * @param redirectAttributes Attributs pour la redirection (messages de succès/erreur)
     * @return Redirection vers la liste en cas de succès, ou retour au formulaire en cas d'erreur
     */
    @PostMapping(&quot;/validate&quot;)
    public String validate(@Valid @ModelAttribute(&quot;ratingDTO&quot;) RatingDTO ratingDTO, 
                          BindingResult result, 
                          Model model,
                          RedirectAttributes redirectAttributes) {
<span class="fc" id="L156">        logger.info(&quot;Attempting to create new Rating: Moody's={}, S&amp;P={}, Fitch={}, Order={}&quot;, </span>
<span class="fc" id="L157">                   ratingDTO.getMoodysRating(), ratingDTO.getSandPRating(), </span>
<span class="fc" id="L158">                   ratingDTO.getFitchRating(), ratingDTO.getOrderNumber());</span>
        
<span class="fc bfc" id="L160" title="All 2 branches covered.">        if (result.hasErrors()) {</span>
<span class="fc" id="L161">            logger.warn(&quot;Validation errors found for new Rating: {}&quot;, </span>
<span class="fc" id="L162">                       result.getAllErrors().stream()</span>
<span class="fc" id="L163">                           .map(error -&gt; error.getDefaultMessage())</span>
<span class="fc" id="L164">                           .collect(Collectors.joining(&quot;, &quot;)));</span>
<span class="fc" id="L165">            return &quot;rating/add&quot;;</span>
        }
        
        try {
<span class="fc" id="L169">            Rating rating = ratingMapper.toEntity(ratingDTO);</span>
<span class="fc" id="L170">            Rating savedRating = ratingService.save(rating);</span>
            
<span class="fc" id="L172">            logger.info(&quot;Successfully created Rating with ID: {} and order: {}&quot;, </span>
<span class="fc" id="L173">                       savedRating.getId(), savedRating.getOrderNumber());</span>
<span class="fc" id="L174">            redirectAttributes.addAttribute(&quot;success&quot;, &quot;Credit rating added successfully&quot;);</span>
<span class="fc" id="L175">            return &quot;redirect:/rating/list&quot;;</span>
            
<span class="fc" id="L177">        } catch (IllegalArgumentException e) {</span>
<span class="fc" id="L178">            logger.warn(&quot;Business validation error for new Rating: {}&quot;, e.getMessage());</span>
<span class="fc" id="L179">            model.addAttribute(&quot;errorMessage&quot;, e.getMessage());</span>
<span class="fc" id="L180">            return &quot;rating/add&quot;;</span>
            
<span class="nc" id="L182">        } catch (Exception e) {</span>
<span class="nc" id="L183">            logger.error(&quot;Unexpected error creating Rating&quot;, e);</span>
<span class="nc" id="L184">            model.addAttribute(&quot;errorMessage&quot;, &quot;An unexpected error occurred: &quot; + e.getMessage());</span>
<span class="nc" id="L185">            return &quot;rating/add&quot;;</span>
        }
    }

    /**
     * Affiche le formulaire de modification d'une notation de crédit existante.
     * 
     * &lt;p&gt;Cette méthode récupère un Rating par son ID depuis le service,
     * le convertit en DTO via le mapper et le passe au formulaire de modification.
     * Elle inclut une validation de l'existence de l'entité et une gestion
     * d'erreurs robuste pour les cas de notations inexistantes.&lt;/p&gt;
     * 
     * @param id L'identifiant du Rating à modifier
     * @param model Le modèle Spring MVC pour passer les données à la vue
     * @return Le nom de la vue &quot;rating/update&quot; ou redirection vers la liste en cas d'erreur
     */
    @GetMapping(&quot;/update/{id}&quot;)
    public String showUpdateForm(@PathVariable Integer id, Model model) {
<span class="fc" id="L203">        logger.info(&quot;Attempting to load Rating for update: ID={}&quot;, id);</span>
        
        try {
<span class="fc" id="L206">            validateId(id);</span>
            
<span class="fc" id="L208">            Rating rating = ratingService.findById(id)</span>
<span class="fc" id="L209">                .orElseThrow(() -&gt; new IllegalArgumentException(&quot;Rating not found with id: &quot; + id));</span>
            
<span class="fc" id="L211">            RatingDTO ratingDTO = ratingMapper.toDTO(rating);</span>
<span class="fc" id="L212">            model.addAttribute(&quot;ratingDTO&quot;, ratingDTO);</span>
            
<span class="fc" id="L214">            logger.info(&quot;Successfully loaded Rating for update: ID={}, Order={}&quot;, </span>
<span class="fc" id="L215">                       id, rating.getOrderNumber());</span>
<span class="fc" id="L216">            return &quot;rating/update&quot;;</span>
            
<span class="fc" id="L218">        } catch (IllegalArgumentException e) {</span>
<span class="fc" id="L219">            logger.warn(&quot;Rating not found for update: ID={}&quot;, id);</span>
<span class="fc" id="L220">            return &quot;redirect:/rating/list?error=notfound&quot;;</span>
            
<span class="fc" id="L222">        } catch (Exception e) {</span>
<span class="fc" id="L223">            logger.error(&quot;Error loading Rating for update: ID={}&quot;, id, e);</span>
<span class="fc" id="L224">            return &quot;redirect:/rating/list?error=unexpected&quot;;</span>
        }
    }

    /**
     * Traite la soumission du formulaire de modification d'une notation de crédit.
     * 
     * &lt;p&gt;Cette méthode valide les données modifiées, vérifie l'existence de l'entité,
     * met à jour l'entité existante via le mapper pour préserver l'état JPA,
     * effectue la sauvegarde via le service et redirige vers la liste avec un
     * message de succès. La mise à jour in-place optimise les performances.&lt;/p&gt;
     * 
     * @param id L'identifiant du Rating à modifier
     * @param ratingDTO Les données modifiées du Rating, validées avec Bean Validation
     * @param result Le résultat de la validation Bean Validation
     * @param model Le modèle Spring MVC pour passer les données à la vue
     * @param redirectAttributes Attributs pour la redirection (messages de succès/erreur)
     * @return Redirection vers la liste en cas de succès, ou retour au formulaire en cas d'erreur
     */
    @PostMapping(&quot;/update/{id}&quot;)
    public String updateRating(@PathVariable Integer id, 
                              @Valid @ModelAttribute RatingDTO ratingDTO,
                              BindingResult result,
                              Model model,
                              RedirectAttributes redirectAttributes) {
<span class="fc" id="L249">        logger.info(&quot;Attempting to update Rating: ID={}&quot;, id);</span>
        
<span class="fc bfc" id="L251" title="All 2 branches covered.">        if (result.hasErrors()) {</span>
<span class="fc" id="L252">            logger.warn(&quot;Validation errors found for Rating update: ID={}, errors={}&quot;, </span>
<span class="fc" id="L253">                       id, result.getAllErrors().stream()</span>
<span class="fc" id="L254">                               .map(error -&gt; error.getDefaultMessage())</span>
<span class="fc" id="L255">                               .collect(Collectors.joining(&quot;, &quot;)));</span>
<span class="fc" id="L256">            ratingDTO.setId(id); // Préserver l'ID pour le formulaire</span>
<span class="fc" id="L257">            return &quot;rating/update&quot;;</span>
        }
        
        try {
<span class="fc" id="L261">            validateId(id);</span>
            
<span class="fc" id="L263">            Rating existingRating = ratingService.findById(id)</span>
<span class="fc" id="L264">                .orElseThrow(() -&gt; new IllegalArgumentException(&quot;Rating not found with id: &quot; + id));</span>
            
<span class="fc" id="L266">            ratingMapper.updateEntityFromDTO(existingRating, ratingDTO);</span>
<span class="fc" id="L267">            Rating updatedRating = ratingService.save(existingRating);</span>
            
<span class="fc" id="L269">            logger.info(&quot;Successfully updated Rating: ID={}, new order={}&quot;, </span>
<span class="fc" id="L270">                       updatedRating.getId(), updatedRating.getOrderNumber());</span>
<span class="fc" id="L271">            redirectAttributes.addAttribute(&quot;success&quot;, &quot;Credit rating updated successfully&quot;);</span>
<span class="fc" id="L272">            return &quot;redirect:/rating/list&quot;;</span>
            
<span class="fc" id="L274">        } catch (IllegalArgumentException e) {</span>
<span class="fc" id="L275">            logger.warn(&quot;Business validation error for Rating update: ID={}, error={}&quot;, </span>
<span class="fc" id="L276">                       id, e.getMessage());</span>
<span class="fc" id="L277">            model.addAttribute(&quot;errorMessage&quot;, e.getMessage());</span>
<span class="fc" id="L278">            ratingDTO.setId(id);</span>
<span class="fc" id="L279">            return &quot;rating/update&quot;;</span>
            
<span class="fc" id="L281">        } catch (Exception e) {</span>
<span class="fc" id="L282">            logger.error(&quot;Unexpected error updating Rating: ID={}&quot;, id, e);</span>
<span class="fc" id="L283">            model.addAttribute(&quot;errorMessage&quot;, &quot;An unexpected error occurred: &quot; + e.getMessage());</span>
<span class="fc" id="L284">            ratingDTO.setId(id);</span>
<span class="fc" id="L285">            return &quot;rating/update&quot;;</span>
        }
    }

    /**
     * Supprime une notation de crédit par son identifiant.
     * 
     * &lt;p&gt;Cette méthode effectue la suppression sécurisée d'un Rating via le service
     * après vérification de l'existence et des contraintes d'intégrité. Elle redirige
     * vers la liste avec un message de succès ou d'erreur selon le résultat de
     * l'opération. La suppression est auditée pour la conformité réglementaire.&lt;/p&gt;
     * 
     * @param id L'identifiant du Rating à supprimer
     * @param redirectAttributes Attributs pour la redirection (messages de succès/erreur)
     * @return Redirection vers la liste avec un message de statut approprié
     */
    @GetMapping(&quot;/delete/{id}&quot;)
    public String deleteRating(@PathVariable Integer id, 
                              RedirectAttributes redirectAttributes) {
<span class="fc" id="L304">        logger.info(&quot;Attempting to delete Rating: ID={}&quot;, id);</span>
        
        try {
<span class="fc" id="L307">            validateId(id);</span>
            
            // Log de la notation avant suppression pour audit
<span class="fc" id="L310">            ratingService.findById(id).ifPresent(rating -&gt; {</span>
<span class="fc" id="L311">                logger.info(&quot;Deleting Rating - ID: {}, Moody's: {}, S&amp;P: {}, Fitch: {}, Order: {}&quot;, </span>
<span class="fc" id="L312">                           rating.getId(), rating.getMoodysRating(), rating.getSandPRating(), </span>
<span class="fc" id="L313">                           rating.getFitchRating(), rating.getOrderNumber());</span>
<span class="fc" id="L314">            });</span>
            
<span class="fc" id="L316">            ratingService.deleteById(id);</span>
            
<span class="fc" id="L318">            logger.info(&quot;Successfully deleted Rating: ID={}&quot;, id);</span>
<span class="fc" id="L319">            redirectAttributes.addAttribute(&quot;success&quot;, &quot;Credit rating deleted successfully&quot;);</span>
            
<span class="fc" id="L321">        } catch (IllegalArgumentException e) {</span>
<span class="fc" id="L322">            logger.warn(&quot;Cannot delete Rating: ID={}, error={}&quot;, id, e.getMessage());</span>
<span class="fc" id="L323">            redirectAttributes.addAttribute(&quot;error&quot;, &quot;notfound&quot;);</span>
            
<span class="fc" id="L325">        } catch (Exception e) {</span>
<span class="fc" id="L326">            logger.error(&quot;Unexpected error deleting Rating: ID={}&quot;, id, e);</span>
<span class="fc" id="L327">            redirectAttributes.addAttribute(&quot;error&quot;, &quot;unexpected&quot;);</span>
<span class="fc" id="L328">        }</span>
        
<span class="fc" id="L330">        return &quot;redirect:/rating/list&quot;;</span>
    }

    /**
     * Affiche les notations filtrées par type (Investment vs Speculative Grade).
     * 
     * &lt;p&gt;Cette méthode permet de filtrer et afficher les notations selon leur
     * qualité de crédit, facilitant l'analyse de portefeuille et la gestion
     * des risques. Elle supporte les filtres standard de l'industrie financière.&lt;/p&gt;
     * 
     * @param type Le type de notation à afficher (&quot;investment&quot;, &quot;speculative&quot;, &quot;all&quot;)
     * @param model Le modèle Spring MVC pour passer les données à la vue
     * @return Le nom de la vue &quot;rating/list&quot; avec les données filtrées
     */
    @GetMapping(&quot;/filter&quot;)
    public String filterByType(@RequestParam String type, Model model) {
        try {
            List&lt;Rating&gt; ratings;
            String filterDescription;
            
<span class="fc bfc" id="L350" title="All 3 branches covered.">            switch (type.toLowerCase()) {</span>
                case &quot;investment&quot;:
<span class="fc" id="L352">                    ratings = ratingService.findInvestmentGrade();</span>
<span class="fc" id="L353">                    filterDescription = &quot;Investment Grade Ratings (BBB-/Baa3 and above)&quot;;</span>
<span class="fc" id="L354">                    break;</span>
                case &quot;speculative&quot;:
<span class="fc" id="L356">                    ratings = ratingService.findSpeculativeGrade();</span>
<span class="fc" id="L357">                    filterDescription = &quot;Speculative Grade Ratings (BB+/Ba1 and below)&quot;;</span>
<span class="fc" id="L358">                    break;</span>
                case &quot;all&quot;:
                default:
<span class="fc" id="L361">                    ratings = ratingService.findAll();</span>
<span class="fc" id="L362">                    filterDescription = &quot;All Credit Ratings&quot;;</span>
                    break;
            }
            
<span class="fc" id="L366">            List&lt;RatingDTO&gt; ratingDTOs = ratings.stream()</span>
<span class="fc" id="L367">                    .map(ratingMapper::toDTO)</span>
<span class="fc" id="L368">                    .collect(Collectors.toList());</span>
            
<span class="fc" id="L370">            model.addAttribute(&quot;ratings&quot;, ratingDTOs);</span>
<span class="fc" id="L371">            model.addAttribute(&quot;filterDescription&quot;, filterDescription);</span>
<span class="fc" id="L372">            model.addAttribute(&quot;activeFilter&quot;, type);</span>
            
<span class="fc" id="L374">            logger.info(&quot;Successfully filtered {} ratings by type: {}&quot;, ratings.size(), type);</span>
<span class="fc" id="L375">            return &quot;rating/list&quot;;</span>
            
<span class="nc" id="L377">        } catch (Exception e) {</span>
<span class="nc" id="L378">            logger.error(&quot;Error filtering ratings by type: {}&quot;, type, e);</span>
<span class="nc" id="L379">            model.addAttribute(&quot;errorMessage&quot;, &quot;Error filtering ratings: &quot; + e.getMessage());</span>
<span class="nc" id="L380">            model.addAttribute(&quot;ratings&quot;, List.of());</span>
<span class="nc" id="L381">            return &quot;rating/list&quot;;</span>
        }
    }

    /**
     * API endpoint pour récupérer les notations au format JSON.
     * 
     * &lt;p&gt;Cette méthode fournit un accès programmatique aux données de notation
     * pour les intégrations avec d'autres systèmes, les analyses quantitatives
     * ou les applications client JavaScript.&lt;/p&gt;
     * 
     * @param agency Agence de notation à filtrer (optionnel: &quot;moodys&quot;, &quot;sp&quot;, &quot;fitch&quot;)
     * @return Liste des notations au format JSON
     */
    @GetMapping(&quot;/api&quot;)
    @ResponseBody
    public List&lt;RatingDTO&gt; getRatingsApi(@RequestParam(required = false) String agency) {
        try {
            List&lt;Rating&gt; ratings;
            
<span class="pc bpc" id="L401" title="1 of 4 branches missed.">            if (agency != null &amp;&amp; !agency.trim().isEmpty()) {</span>
<span class="fc" id="L402">                ratings = ratingService.findByAgency(agency.toUpperCase());</span>
<span class="fc" id="L403">                logger.info(&quot;API request for {} ratings returned {} results&quot;, agency, ratings.size());</span>
            } else {
<span class="fc" id="L405">                ratings = ratingService.findAll();</span>
<span class="fc" id="L406">                logger.info(&quot;API request for all ratings returned {} results&quot;, ratings.size());</span>
            }
            
<span class="fc" id="L409">            return ratings.stream()</span>
<span class="fc" id="L410">                    .map(ratingMapper::toDTO)</span>
<span class="fc" id="L411">                    .collect(Collectors.toList());</span>
                    
<span class="fc" id="L413">        } catch (Exception e) {</span>
<span class="fc" id="L414">            logger.error(&quot;Error in ratings API endpoint&quot;, e);</span>
<span class="fc" id="L415">            return List.of(); // Retourne liste vide en cas d'erreur</span>
        }
    }
    
    /**
     * Gestionnaire d'exceptions global pour ce contrôleur.
     * 
     * &lt;p&gt;Cette méthode capture toutes les exceptions non gérées spécifiquement
     * dans les autres méthodes du contrôleur. Elle retourne une vue d'erreur
     * avec un message approprié et une liste vide pour éviter les erreurs
     * d'affichage dans la vue.&lt;/p&gt;
     * 
     * @param e L'exception capturée
     * @param model Le modèle Spring MVC pour passer les données à la vue
     * @return Le nom de la vue &quot;rating/list&quot; avec un message d'erreur
     */
    @ExceptionHandler(Exception.class)
    public String handleGenericException(Exception e, Model model) {
<span class="fc" id="L433">        logger.error(&quot;Unhandled exception in RatingController&quot;, e);</span>
<span class="fc" id="L434">        model.addAttribute(&quot;errorMessage&quot;, &quot;An unexpected error occurred: &quot; + e.getMessage());</span>
<span class="fc" id="L435">        model.addAttribute(&quot;ratings&quot;, List.of()); // Liste vide en cas d'erreur</span>
<span class="fc" id="L436">        return &quot;rating/list&quot;;</span>
    }
    
    /**
     * Méthode utilitaire pour ajouter les messages de statut au modèle.
     * 
     * &lt;p&gt;Cette méthode privée centralise la logique d'ajout des messages
     * de succès et d'erreur au modèle en fonction des paramètres reçus
     * lors des redirections. Elle vérifie que les messages ne sont pas
     * null ou vides avant de les ajouter au modèle.&lt;/p&gt;
     * 
     * @param model Le modèle Spring MVC auquel ajouter les messages
     * @param success Le message de succès à afficher (peut être null)
     * @param error Le message d'erreur à afficher (peut être null)
     */
    private void addStatusMessages(Model model, String success, String error) {
<span class="pc bpc" id="L452" title="1 of 4 branches missed.">        if (success != null &amp;&amp; !success.trim().isEmpty()) {</span>
<span class="fc" id="L453">            model.addAttribute(&quot;successMessage&quot;, success);</span>
        }
        
<span class="pc bpc" id="L456" title="1 of 4 branches missed.">        if (error != null &amp;&amp; !error.trim().isEmpty()) {</span>
<span class="fc bfc" id="L457" title="All 4 branches covered.">            switch (error) {</span>
                case &quot;notfound&quot;:
<span class="fc" id="L459">                    model.addAttribute(&quot;errorMessage&quot;, &quot;Credit rating not found&quot;);</span>
<span class="fc" id="L460">                    break;</span>
                case &quot;invalid&quot;:
<span class="fc" id="L462">                    model.addAttribute(&quot;errorMessage&quot;, &quot;Invalid rating ID provided&quot;);</span>
<span class="fc" id="L463">                    break;</span>
                case &quot;unexpected&quot;:
<span class="fc" id="L465">                    model.addAttribute(&quot;errorMessage&quot;, &quot;An unexpected error occurred&quot;);</span>
<span class="fc" id="L466">                    break;</span>
                default:
<span class="fc" id="L468">                    model.addAttribute(&quot;errorMessage&quot;, error);</span>
                    break;
            }
        }
<span class="fc" id="L472">    }</span>

    /**
     * Méthode utilitaire pour valider les paramètres d'ID.
     * 
     * &lt;p&gt;Validation centralisée des identifiants pour éviter la duplication
     * de code et assurer une validation cohérente dans tout le contrôleur.&lt;/p&gt;
     * 
     * @param id L'identifiant à valider
     * @throws IllegalArgumentException si l'ID est null ou invalide
     */
    private void validateId(Integer id) {
<span class="pc bpc" id="L484" title="1 of 4 branches missed.">        if (id == null || id &lt;= 0) {</span>
<span class="fc" id="L485">            throw new IllegalArgumentException(&quot;Invalid ID: &quot; + id);</span>
        }
<span class="fc" id="L487">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>